package code;

public enum OpCode {

	// Lista de comandos uteis

    //Desvios

    // ret i32 5                       ; Return an integer value of 5
    // ret void  

    // br i1 %cond, label %IfEqual, label %IfUnequal 
    // IfEqual:
    //   ret i32 1
    // IfUnequal:
    //   ret i32 0
    
    // br i1


    //; Emulate a conditional br instruction
    // %Val = zext i1 %value to i32
    // switch i32 %Val, label %truedest [ i32 0, label %falsedest ]

    // ; Emulate an unconditional br instruction
    // switch i32 0, label %dest [ ]

    // ; Implement a jump table:
    // switch i32 %val, label %otherwise [ i32 0, label %onzero
    //                                     i32 1, label %onone
    //                                     i32 2, label %ontwo ]

    //Aritmeticos

    // <result> = add i32 4, %var          ; yields i32:result = 4 + %var int

    // <result> = fadd [fast-math flags]* <ty> <op1>, <op2>   ; yields ty:result float

    // <result> = sub i32 4, %var          ; yields i32:result = 4 - %var
    // <result> = sub i32 0, %val          ; yields i32:result = -%var

    // <result> = fsub float 4.0, %var           ; yields float:result = 4.0 - %var
    // <result> = fsub float -0.0, %val          ; yields float:result = -%var

    // <result> = mul i32 4, %var          ; yields i32:result = 4 * %var

    // <result> = fmul float 4.0, %var          ; yields float:result = 4.0 * %var

    // <result> = udiv i32 4, %var          ; yields i32:result = 4 / %var unsigned integer result, integer arguments

    // <result> = sdiv i32 4, %var          ; yields i32:result = 4 / %var signed integer result, integer arguments

    // <result> = fdiv float 4.0, %var          ; yields float:result = 4.0 / %var floats

    // <result> = urem i32 4, %var          ; yields i32:result = 4 % %var pega o resto de inteiros e da unsigned

    // <result> = frem float 4.0, %var          ; yields float:result = 4.0 % %var resto de floats

    //Vetores != array

    // <result> = extractelement <4 x i32> %vec, i32 0    ; yields i32 remove valor escalar, parametros são vetor e indice

    // <result> = insertelement <4 x i32> %vec, i32 1, i32 0    ; yields <4 x i32>

    //Array 
    // <result> = extractvalue {i32, float} %agg, 0    ; yields i32

    // %agg1 = insertvalue {i32, float} undef, i32 1, 0  


    ///Memória
    // %ptr = alloca i32                             ; yields i32*:ptr
    // %ptr = alloca i32, i32 4                      ; yields i32*:ptr aloca na função

    // %val = load i32, i32* %ptr                      ; yields i32:val = i32 3 The ‘load’ instruction is used to read from memory.

    //store i32 3, i32* %ptr                          ; yields void The ‘store’ instruction is used to write to memory.

    // %ptr = alloca i32                               ; yields i32*:ptr
    // store i32 3, i32* %ptr                          ; yields void
    // %val = load i32, i32* %ptr                      ; yields i32:val = i32 3

    // %arrayidx = getelementptr inbounds %struct.ST, %struct.ST* %s, i64 1, i32 2, i32 1, i64 5, i64 13 The ‘getelementptr’ instruction is used to get the address of a subelement of an aggregate data structure. It performs address calculation only and does not access memory. The instruction can also be used to calculate a vector of such addresses.

    //Conversões

    //     %X = fpext float 3.125 to double         ; yields double:3.125000e+00 
    // The ‘fpext’ extends a floating-point value to a larger floating-point value.
    // %Y = fpext double %X to fp128            ; yields fp128:0xL00000000000000004000900000000000


    // %X = uitofp i32 257 to float         ; yields float:257.0

    // X = sitofp i32 257 to float         ; yields float:257.0
    // %Y = sitofp i8 -1 to double          ; yields double:-1.0



    //miss

    // <result> = icmp eq i32 4, 5          ; yields: result=false comparew
    // <result> = fcmp one float 4.0, 5.0    ; yields: result=true


    //call i32 (i8*, ...)* @printf(i8* %msg, i32 12, i8 42)        ; yields i32





	// ---------------------------------------------------
	// Basic ops
	
    HALT("HALT", 0),
    NOOP("NOOP", 0),

    // ---------------------------------------------------
    // Arith ops
    
    ADDi("ADDi", 3),	// ADDi ix, iy, iz	; ix <- iy + iz
    ADDf("ADDf", 3),	// ADDf fx, fy, fz	; fx <- fy + fz
    SUBi("SUBi", 3),	// SUBi ix, iy, iz	; ix <- iy - iz
    SUBf("SUBf", 3),	// SUBf fx, fy, fz	; fx <- fy - fz
    MULi("MULi", 3),	// MULi ix, iy, iz	; ix <- iy * iz
    MULf("MULf", 3),	// MULf fx, fy, fz	; fx <- fy * fz
    DIVi("DIVi", 3),	// DIVi ix, iy, iz	; ix <- iy / iz
    DIVf("DIVf", 3),	// DIVf fx, fy, fz	; fx <- fy / fz
    // Widen to float
    WIDf("WIDf", 2),	// WIDf fx, iy		; fx <- (float) iy

    // ---------------------------------------------------
    // Logic ops
    
    // Logical OR
    OROR("OROR", 3), 	// OROR ix, iy, iz	; ix <- (bool) iy || (bool) iz
    // Equality
    EQUi("EQUi", 3), 	// EQUi ix, iy, iz	; ix <- iy == iz ? 1 : 0
    EQUf("EQUf", 3),	// EQUf ix, fy, fz	; ix <- fy == fz ? 1 : 0
    EQUs("EQUs", 3), 	// EQUs ix, iy, iz	; ix <- str_tab[iy] == str_tab[iz] ? 1 : 0
    // Less than
    LTHi("LTHi", 3), 	// LTHi ix, iy, iz	; ix <- iy < iz ? 1 : 0
    LTHf("LTHf", 3), 	// LTHi ix, fy, fz	; ix <- iy < iz ? 1 : 0
    LTHs("LTHs", 3), 	// LTHs ix, iy, iz	; ix <- str_tab[iy] < str_tab[iz] ? 1 : 0

    // ---------------------------------------------------
    // Branches and jumps
    
    // Absolute jump
    JUMP("JUMP", 1),	// JUMP addr		; PC <- addr
    // Branch on true
    BOTb("BOTb", 2), 	// BOTb ix, off		; PC <- PC + off, if ix == 1
    // Branch on false
    BOFb("BOFb", 2),	// BOFb ix, off		; PC <- PC + off, if ix == 0

    // ---------------------------------------------------
    // Loads and stores

    // Load word (from address)
    LDWi("LDWi", 2), 	// LDWi ix, addr	; ix <- data_mem[addr]
    LDWf("LDWf", 2), 	// LDWf fx, addr	; fx <- data_mem[addr]
    // Load immediate (constant)
    LDIi("LDIi", 2), 	// LDIi ix, int_const	; ix <- int_const
    LDIf("LDIf", 2),  	// LDIf fx, float_const	; fx <- float_const (must be inside an int)
    // Store word (to address)
    STWi("STWi", 2),  	// STWi addr, ix		; data_mem[addr] <- ix
    STWf("STWf", 2),  	// STWf addr, fx		; data_mem[addr] <- fx
           

    // ---------------------------------------------------
    // Strings
    
    // (These strings instructions are obviously not present in real archs.
    //  The rationale for creating and using them here is simply for convenience:
    //  Normally, these are handled by a low level language lib or OS system call
    //  such as those present in 'libc', etc. However, involving real OS interfaces
    //  here will complicate the game considerably. Thus, we cheat by creating
    //  this high level interface for string handling.)
    
    // Store string
    SSTR("SSTR", 1),  // SSTR str_const		; str_tab <- str_const
    // Catenate
    CATs("CATs", 3),  // CATs ix, iy, iz	; str_tab[ix] <- str_tab[iy] + str_tab[iz]
    // Bool to String
    B2Ss("B2Ss", 2),  // B2Ss ix, iy		; ix <- @str_tab <- register iy (as str)
    // Integer to String
    I2Ss("I2Ss", 2),  // I2Ss ix, iy		; ix <- @str_tab <- register iy (as str)
    // Real to String
    R2Ss("R2Ss", 2),  // R2Ss ix, fy		; ix <- @str_tab <- register fy (as str)

    // ---------------------------------------------------
    // System calls, for I/O (see below)
    
    CALL("CALL", 2); // CALL code, x
	
	// CALL (very basic simulation of OS system calls)
	// . code: sets the operation to be called.
	// . x: register involved in the operation.
	// List of calls:
	// ----------------------------------------------------------------------------
	// code | x  | Description
	// ----------- -----------------------------------------------------------
	// 0   | ix | Read int:   register ix <- int  from stdin
	// 1   | fx | Read real:  register fx <- real from stdin
	// 2   | ix | Read bool:  register ix <- bool from stdin (as int)
	// 3   | ix | Read str:   str_tab[ix] <- str from stdin
	// 4   | ix | Write int:  stdout <- register ix (as str)
	// 5   | fx | Write real: stdout <- register fx (as str)
	// 6   | ix | Write bool: stdout <- register ix (as str)
	// 7   | ix | Write str:  stdout <- str_tab[ix]
	// ----------------------------------------------------------------------------
	// OBS.: All strings in memory are null ('\0') terminated, like in C.
	// ----------------------------------------------------------------------------
    
	public final String name;
	public final int opCount;
	
	private OpCode(String name, int opCount) {
		this.name = name;
		this.opCount = opCount;
	}
	
	public String toString() {
		return this.name;
	}
}